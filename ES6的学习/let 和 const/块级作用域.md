# 块级作用域

## 为什么需要块级作用域

ES5 只有 全局作用域 和 函数作用域，没有 块级作用域，这样会有很多不合理的场景：

    · 内层变量可能会覆盖外层变量

```.js
    var tmp = new Date()

    function f () {
        console.log(tmp)
        if(false) {
            var tmp = 'hello world'
        }
    }

    f() // undefined
```

    · 用来计数的循环变量泄露为全局变量

```.js
    var s = 'hello'
    for (var i=0; i<s.length; i++) {
        console.log(s[i])
    }
    console.log(i)
    

    该代码中，变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量
```

## ES6的块级作用域

let 实际上为 JavaScript 新增了块级作用域

    · ES6允许块级作用域的任意嵌套
    · 外层作用域无法读取内层作用域的变量
    · 内层作用域可以定义外层作用域的同名变量
    · 块级作用域的出现，实际上使得获得广泛应用的 立即执行函数（IIFE）不再必要了

```.js
    // IIFE 写法
    (function () {
        var tmp = ...;
        ...
    }());

    // 块级作用域写法
    {
        let tmp = ...;
        ...
    }
```

## 块级作用域 与 函数声明

    ES5 规定，函数只能在 顶层作用域 和 函数作用域 之中声明，不能在 块级作用域 声明
    ES6 引入了 块级作用域，明确允许在块级作用域之中声明函数。
    ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用

    只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 let 处理
    · 允许在块级作用域内声明函数
    · 函数声明类似于 var，即会提升到 全局作用域 或 函数作用域 的头部
    · 同时，函数声明还会提升到所在的 块级作用域 的 头部

    考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

## do 表达式

    目前只是提案，还无法使用这个功能

    · 本质上，块级作用域 是一个语句，将多个操作封装在一起，没有返回值
```.js
    {
        let t = f()
        t = t * t + 1
    }
```

    · 提案：在 块级作用域 之前加上 do，使它变为 do表达式，然后就会返回内部最后执行的表达式的值
```.js
    let x = do {
        let t = f()
        t * t + 1
    }
    // 变量 x 会得到整个 块级作用域 的 返回值 (t * t + 1)
```