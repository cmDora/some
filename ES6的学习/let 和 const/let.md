# let

    声明的变量只在 let 命令所在的代码块内有效

## var 与 let 区别

```.js
    // var

    var a = []
    for (var i=0; i<10; i++) {
        a[i] = function () {
            console.log(i)
        }
    }
    a[6]()  // 10

    // let

    var a = []
    for (let i=0; i<10; i++> {
        a[i] = function () {
            console.log(i)
        }
    })
    a[6]()  // 6
```

以上代码可以看出 var 和 let 的区别所在：

    var：
    变量 i 是 var 命令声明的，在全局范围都有效，所以全局只有一个变量 i
    所有数组 a 的成员里面的 i，指向的都是同一个 i
    导致运行时输出的是最后一轮的 i 的值

    let：
    变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量
    JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行运算

## for 循环

    for 循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域

```.js
    for (let i=0; i<3; i++) {
        let i = 'abc'
        console.log(i)
    }
```

以上代码可以正确执行。表明函数内部的变量 i 与 循环变量 i 不在同一个作用域，有各自单独的作用域

## 不存在变量提升

    var 命令会发生 变量提升 的现象，变量可在声明之前使用，值为 undefined

    let 所声明的变量一定要在声明之后使用，否则 报错

## 暂时性死区

    只要块级作用域内存在 let 命令，它所声明的变量就 绑定（binding）这个区域，不再受外部影响

    （temporal dead zone，简称 TDZ）暂时性死区

    暂存性死区 也意味着 typeof 不再是一个百分之百安全的操作
    如果变量没有被声明，使用 typeof 反而不会报错

## 不允许重复声明

    let 不允许在相同作用域内，重复声明同一个变量