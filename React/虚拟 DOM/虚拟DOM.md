# 虚拟 DOM

	react 中最大的亮点就是 虚拟 DOM

## 传统 web app 和 DOM 的交互 

	传统 web app 和 DOM 直接交互，由 App 来控制 DOM 的 构建 和 渲染、元素属性的读写、事件的注册 和 销毁 等等
	当新产品刚上线的时候，这种做法看起来也挺好。但随着产品功能越来越丰富、代码越来越多、开发团队人员越来越多。那么格局就会很乱

	
```.html
	// 传统 web App
	
		   build
	App    ===>   	DOM
	       modify
		  
		  event
	App    <===  DOM
```

## react 的虚拟 DOM 和单向数据流

	它可以很好的解决上面的问题

```.html
	// React Web App
	
			build				build
	App		===>	虚拟 DOM 		===>	DOM
			modify				modify
	
			event				event
	App		<===	虚拟 DOM 		<===	DOM
```

## 虚拟 DOM

```.html
	虚拟 DOM 是在 DOM 的基础上建立了一个抽象层，我们对 数据 和 状态 所做的任何改动，都会被 自动且高效 的同步到 虚拟 DOM，然后再批量同步到 DOM 中
	
	虚拟 DOM 会使得 App 只关心 数据 和 组件 的执行结果，中间产生的 DOM 操作不需要 App 干预，而且通过 虚拟 DOM 来生成 DOM，会有一项非常可观收益 —— 性能
```

```.html
	· 所有人都知道 DOM 慢，渲染一个空的 DIV，浏览器需要为这个 DIV 生成几百个属性，而虚拟 DOM 只有6个，所以减少不必要的 重排重绘 以及 DOM 读写 能够对页面渲染性能有大幅提升
	
	· 那么我们来看看 虚拟 DOM 是怎么做的：React 会在内存中维护一个 虚拟 DOM 树，当我们对这个树进行 读或写 的时候，实际上是对 虚拟 DOM 进行的。当数据变化时，然后 React 会自动更新 虚拟 DOM，然后拿新的 虚拟 DOM 和 旧的 虚拟 DOM 进行对比（diff），找到有变更的部分，得出一个 Patch，然后将这个 Patch 放到一个队列里，最终批量更新这些 Patch 到 DOM 中
	
	· 这样的 机制 可以保证即便是 根节点 数据的变化，最终表现在 DOM 上的修改也只是受这个数据影响的部分，可以保证非常高效的渲染
	
	· 但这样也是有一定的缺陷的 —— 首次渲染大量 DOM 时因为多了一层 虚拟 DOM 的计算，会比 innerHTML 插入的方式慢，所以使用时需要确保不要一次性渲染大量 DOM
```